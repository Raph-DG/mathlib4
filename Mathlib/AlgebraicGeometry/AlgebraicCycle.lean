/-
Copyright (c) 2025 Raphael Douglas Giles. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Raphael Douglas Giles
-/
import Mathlib

open AlgebraicGeometry Set Order LocallyRingedSpace Topology TopologicalSpace
  CategoryTheory

/-!
# Algebraic Cycles

We define the category of `AffineScheme`s as the essential image of `Spec`.
We also define predicates about affine schemes and affine open sets.

## Main definitions

-/

universe u v
variable (R : Type*)
         [CommRing R]
         (i : ‚Ñï)
         {X Y : Scheme.{u}}

abbrev AlgebraicCycle (X : Scheme) := Function.locallyFinsuppWithin (‚ä§ : Set X) ‚Ñ§

structure HomogenousCycle (X : Scheme) (d : ‚Ñï) where
  cycle : AlgebraicCycle X
  homogenous : ‚àÄ x ‚àà cycle.support, height x = d

namespace AlgebraicCycle

variable (f : X ‚ü∂ Y)
         (c : AlgebraicCycle X)
         (x : X)
         (z : Y)

/--
The cycle containing a single point with a chosen coefficient
-/
noncomputable
def single (coeff : ‚Ñ§) : AlgebraicCycle X where
  toFun := Set.indicator {x} (Function.const X coeff)
  supportWithinDomain' := by simp
  supportLocallyFiniteWithinDomain' z hz :=
    ‚ü®‚ä§, ‚ü®Filter.univ_mem' fun a ‚Ü¶ trivial, by simp [‚Üê Function.const_def, toFinite]‚ü©‚ü©

/--
Implementation detail for the pushforward; the support of a cycle on X intersected with the preimage
of a point z : Y along a morphism f : X ‚ü∂ Y.
-/
def preimageSupport : Set X :=
  f.base ‚Åª¬π' {z} ‚à© c.support

/--
Implementation detail for the pushforward; the support of a cycle on X intersected with the preimage
of a point z : Y along a quasicompact morphism f : X ‚ü∂ Y is finite.
-/
def preimageSupportFinite [qf : QuasiCompact f] :
 (preimageSupport f c z).Finite :=
 supportLocallyFiniteWithin_top_inter_compact_finite c.supportLocallyFiniteWithinDomain' <|
  QuasiCompact.isCompact_preimage_singleton f z

noncomputable
def _root_.AlgebraicGeometry.LocallyRingedSpace.Hom.degree : ‚Ñï := @Module.finrank
    (IsLocalRing.ResidueField (Y.presheaf.stalk (f.base x)))
    (IsLocalRing.ResidueField (X.presheaf.stalk x))
    (by infer_instance)
    (by infer_instance)
    (by have :=
      RingHom.toAlgebra (IsLocalRing.ResidueField.map (f.stalkMap x).hom);exact Algebra.toModule)

open Classical in
noncomputable
def mapAux {Y : Scheme} (f : X ‚ü∂ Y) (x : X) : ‚Ñ§ :=
  if height x = height (f.base x) then Hom.degree f x else 0

lemma map_locally_finite {Y : Scheme}
  (f : X ‚ü∂ Y) [qc : QuasiCompact f] (c : AlgebraicCycle X) :
  ‚àÄ z ‚àà (‚ä§ : Set Y), ‚àÉ t ‚àà ùìù z, (t ‚à© Function.support fun z ‚Ü¶
  ‚àë x ‚àà (preimageSupportFinite f c z).toFinset, (c x) * mapAux f x).Finite := by
  intro y hy
  have : ‚àÉ W : Y.Opens, IsAffineOpen W ‚àß y ‚àà W := by sorry
  obtain ‚ü®W, hW‚ü© := this
  have cpct : IsCompact (f.base ‚Åª¬π' W) := qc.1 W.carrier W.is_open' <|
     AlgebraicGeometry.IsAffineOpen.isCompact hW.1
  use W
  refine ‚ü®IsOpen.mem_nhds (Opens.isOpen W) hW.2, ?_‚ü©

  have pbfinite : (f.base ‚Åª¬π' W ‚à© Function.support c).Finite :=
   supportLocallyFiniteWithin_top_inter_compact_finite c.supportLocallyFiniteWithinDomain' cpct

  suffices (W.carrier ‚à© {z : Y | (preimageSupport f c z).Nonempty}).Finite by
      apply Finite.subset this
      apply inter_subset_inter Set.Subset.rfl
      intro x
      simp
      contrapose!
      intro aux
      rw [Finset.sum_eq_zero]
      intro x hx
      simp only [Finite.mem_toFinset, aux] at hx
      simp only [mem_empty_iff_false] at hx

  have : W.carrier ‚à© {z | (preimageSupport f c z).Nonempty} ‚äÜ
    f.base '' (f.base ‚Åª¬π' ((W.carrier ‚à© {z | (preimageSupport f c z).Nonempty})) ‚à© c.support) := by
    intro a ha
    rw [@image_preimage_inter]
    suffices a ‚àà f.base '' c.support by
      exact mem_inter ha this
    have := ha.2.some_mem
    simp[preimageSupport] at this
    simp
    use ha.2.some
    constructor
    ¬∑ exact this.2
    ¬∑ exact this.1

  apply Finite.subset _ this
  apply Finite.image
  rw[preimage_inter]
  have : f.base ‚Åª¬π' W.carrier ‚à© f.base ‚Åª¬π' {z | (preimageSupport f c z).Nonempty} ‚à© c.support ‚äÜ
      f.base ‚Åª¬π' W.carrier ‚à© (‚ãÉ z : Y, preimageSupport f c z) := by
    intro p hp
    simp[preimageSupport] at hp ‚ä¢
    constructor
    ¬∑ exact hp.1.1
    ¬∑ exact hp.2

  apply Finite.subset _ this
  rw[inter_iUnion]
  simp[preimageSupport]
  suffices (‚ãÉ i : Y, f.base ‚Åª¬π' W.carrier ‚à© c.support).Finite by
    apply Finite.subset this
    simp
    intro y x hx
    simp at hx ‚ä¢
    constructor
    ¬∑ exact hx.1
    ¬∑ constructor
      ¬∑ exact Nonempty.intro y
      ¬∑ exact hx.2.2

  suffices (f.base ‚Åª¬π' W.carrier ‚à© c.support).Finite by
    apply Finite.subset this
    intro a ha
    simp at ha ‚ä¢
    constructor
    ¬∑ exact ha.1
    ¬∑ exact ha.2.2
  exact pbfinite

open Classical in
noncomputable
def map {Y : Scheme}
  (f : X ‚ü∂ Y) [qc : QuasiCompact f] (c : AlgebraicCycle X) : AlgebraicCycle Y where
  toFun z := (‚àë x ‚àà (preimageSupportFinite f c z).toFinset, (c x) * mapAux f x)
  supportWithinDomain' := by simp
  supportLocallyFiniteWithinDomain' := fun z a ‚Ü¶ map_locally_finite f c z a

@[simp]
lemma map_id (c : AlgebraicCycle X) :
    map (ùüô X) c = c := by
   ext z
   have : (c z ‚â† 0 ‚àß (preimageSupportFinite (ùüô X) c z).toFinset = {z}) ‚à®
          (c z = 0 ‚àß (preimageSupportFinite (ùüô X) c z).toFinset = ‚àÖ) := by
    simp[preimageSupportFinite, preimageSupport, Finite.toFinset]
    by_cases o : c z = 0
    ¬∑ exact Or.inr o
    ¬∑ apply Or.inl
      refine ‚ü®o, ?_‚ü©
      ext a
      simp only [mem_toFinset, mem_inter_iff, mem_singleton_iff, Function.mem_support, ne_eq,
        Finset.mem_singleton, and_iff_left_iff_imp]
      intro h
      rw[h]
      exact o
   suffices (map (ùüô X) c).toFun z = c.toFun z from this
   obtain h | h := this
   all_goals simp[map, mapAux]
             rw[h.2]
             simp [Hom.degree]
             try rfl
             try exact h.1.symm

end AlgebraicCycle
